/*
Реализовать шаблон для задания «умного» указателя по аналогии шаблона
std::unique_ptr. В шаблоне предусмотреть конструктор, который получает «сырой»
указатель, деструктор, конструкторы копирования и перемещения (что-то
удаляется), операторы присваивания с копированием и перемещением (что-то
удаляется), метод get, возвращающий «сырой указатель», выполнить перегрузку
операций * и ->, запретить создание копий объектов, реализовать перемещение.
*/

template <typename T> class SmartPointer {

private:
  // Указатель на управляемый объект.
  T *ptr_;

public:
  // Конструктор, принимающий "сырой" указатель.
  explicit SmartPointer(T *ptr = nullptr) : ptr_(ptr) {}

  // Деструктор, освобождающий управляемый объект.
  ~SmartPointer() { delete ptr_; }

  // Конструктор перемещения, захватывающий управляемый объект у другого умного
  // указателя.
  SmartPointer(SmartPointer &&other) noexcept : ptr_(other.ptr_) {
    // Устанавливаем указатель other в nullptr, чтобы избежать удаления объекта
    // при уничтожении other.
    other.ptr_ = nullptr;
  }

  // Оператор перемещения.
  SmartPointer &operator=(SmartPointer &&other) noexcept {
    if (this != &other) {
      // Удаляем текущий управляемый объект.
      delete ptr_;
      // Захватываем управляемый объект у other.
      ptr_ = other.ptr_;
      // Устанавливаем указатель other в nullptr, чтобы избежать удаления
      // объекта при уничтожении other.
      other.ptr_ = nullptr;
    }
    return *this;
  }

  // Конструктор копирования и оператор присваивания запрещены
  // для обеспечения уникальности владения.
  SmartPointer(const SmartPointer &) = delete;
  SmartPointer &operator=(const SmartPointer &) = delete;

  // Возвращает "сырой" указатель на управляемый объект.
  T *get() const noexcept { return ptr_; }

  // Оператор разыменования умного указателя.
  T &operator*() const { return *ptr_; }

  // Оператор "->", позволяющий использовать умный указатель как обычный
  // указатель на объект.
  T *operator->() const { return ptr_; }
};
